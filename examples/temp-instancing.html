<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8" />

    <title>twgl.js - twgl cube</title>
    <style>
      body {
        margin: 0;
        font-family: monospace;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      #b {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 2;
      }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>
    <div id="b"><a href="https://twgljs.org">twgl.js</a> - instancing</div>
  </body>

  <script id="vs" type="notjs">
    uniform mat4 u_viewProjection;
    uniform vec3 u_lightWorldPos;
    uniform mat4 u_viewInverse;
    uniform float u_shininess;

    attribute vec4 u_ColourInst;
    attribute mat4 u_WorldMatrixInst;
    attribute vec4 position;
    attribute vec3 normal;

    varying vec4 v_position;
    varying vec4 v_color;
    varying vec4 v_lighting;

    vec4 lit(float l ,float h, float m) {
      return vec4(1.0,
                  max(l, 0.0),
                  (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
                  1.0);
    }

    void main() {
      v_color = u_ColourInst;
      vec4 worldPosition = u_WorldMatrixInst * position;
      v_position = u_viewProjection * worldPosition;
      vec3 normal = (u_WorldMatrixInst * vec4(normal, 0)).xyz;
      vec3 surfaceToLight = normalize(u_lightWorldPos - worldPosition.xyz);
      vec3 surfaceToView = normalize(u_viewInverse[3].xyz - worldPosition.xyz);
      gl_Position = v_position;


      vec3 halfVector = normalize(surfaceToLight + surfaceToView);
      v_lighting = lit(dot(normal, surfaceToLight),
                        dot(normal, halfVector), u_shininess);
    }
  </script>
  <script id="fs" type="notjs">
    precision mediump float;

    varying vec4 v_position;
    varying vec4 v_color;
    varying vec4 v_lighting;

    uniform vec4 u_lightColor;
    uniform vec4 u_ambient;
    uniform vec4 u_specular;
    uniform float u_specularFactor;

    void main() {
      vec4 diffuseColor = v_color;

      vec4 outColor = vec4((
      u_lightColor * (diffuseColor * v_lighting.y + diffuseColor * u_ambient +
                    u_specular * v_lighting.z * u_specularFactor)).rgb,
          diffuseColor.a);

      gl_FragColor = outColor;
    }
  </script>
  <script type="module">
    import * as twgl from 'https://cdnjs.cloudflare.com/ajax/libs/twgl.js/5.5.1/twgl-full.module.js'
    function main() {
      const m4 = twgl.m4
      const gl = document.getElementById('c').getContext('webgl')
      twgl.addExtensionsToContext(gl)
      if (!gl.drawArraysInstanced || !gl.createVertexArray) {
        alert('need drawArraysInstanced and createVertexArray') // eslint-disable-line
        return
      }
      const programInfo = twgl.createProgramInfo(gl, ['vs', 'fs'])

      function rand(min, max) {
        if (max === undefined) {
          max = min
          min = 0
        }
        return min + Math.random() * (max - min)
      }

      const numInstances = 60000
      const instanceWorlds = new Float32Array(numInstances * 16)
      const instanceColors = []
      const r = 70
      for (let i = 0; i < numInstances; ++i) {
        const mat = new Float32Array(instanceWorlds.buffer, i * 16 * 4, 16)
        m4.translation([rand(-r, r), rand(-r, r), rand(-r, r)], mat)
        m4.rotateZ(mat, rand(0, Math.PI * 2), mat)
        m4.rotateX(mat, rand(0, Math.PI * 2), mat)

        instanceColors.push(rand(1), rand(1), rand(1))
      }

      let vertArrays = twgl.primitives.createSphereVertices(1, 16, 12)

      vertArrays.u_WorldMatrixInst = {
        numComponents: 16,
        data: instanceWorlds,
        divisor: 1,
      }

      vertArrays.u_ColourInst = {
        numComponents: 3,
        data: instanceColors,
        divisor: 1,
      }

      const bufferInfo = twgl.createBufferInfoFromArrays(gl, vertArrays)
      const vertexArrayInfo = twgl.createVertexArrayInfo(gl, programInfo, bufferInfo)

      const uniforms = {
        u_lightWorldPos: [1, 8, -30],
        u_lightColor: [1, 1, 1, 1],
        u_ambient: [0, 0, 0, 1],
        u_specular: [1, 1, 1, 1],
        u_shininess: 200,
        u_specularFactor: 1,
      }

      const objList = [
        {
          programInfo: programInfo,
          vertexArrayInfo: vertexArrayInfo,
          uniforms: uniforms,
          instanceCount: numInstances,
        },
      ]

      function render(time) {
        time *= 0.001
        twgl.resizeCanvasToDisplaySize(gl.canvas)
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

        gl.enable(gl.DEPTH_TEST)
        gl.enable(gl.CULL_FACE)
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

        const fov = (30 * Math.PI) / 180
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight
        const zNear = 0.5
        const zFar = 500
        const projection = m4.perspective(fov, aspect, zNear, zFar)
        const radius = 25
        const speed = time * 0.1
        const eye = [Math.sin(speed) * radius, Math.sin(speed * 0.7) * 10, Math.cos(speed) * radius]
        const target = [0, 0, 0]
        const up = [0, 1, 0]

        const camera = m4.lookAt(eye, target, up)
        const view = m4.inverse(camera)
        uniforms.u_viewProjection = m4.multiply(projection, view)
        uniforms.u_viewInverse = camera

        gl.useProgram(programInfo.program)
        twgl.setBuffersAndAttributes(gl, programInfo, vertexArrayInfo)
        twgl.setUniforms(programInfo, uniforms)
        // do it with drawObjectList (not you'd probably make/update the list outside the render loop
        twgl.drawObjectList(gl, objList)

        requestAnimationFrame(render)
      }
      requestAnimationFrame(render)
    }
    main()
  </script>
</html>
